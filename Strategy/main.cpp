#include "Strategy.h"

int main()
{
	// 策略;
	Strategy *ak47 = new AK47();
	Strategy *knife = new Knife();

	// 
	Context* pCharacter = new King();
	pCharacter->Fight();

	pCharacter->SetWeapon(ak47);
	pCharacter->Fight();

	pCharacter->SetWeapon(knife);
	pCharacter->Fight();

	return 0;
}

/*************************************************************************************************************************

适用性;
	1. 多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为;
	2. 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现;
	3. 对客户隐藏具体策略(算法)的实现细节，彼此完全独立;

优点;
	1. 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复;
	2. 使用策略模式可以避免使用多重条件(if-else)语句;
	多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后;

缺点;
	1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类;
	换言之，策略模式只适用于客户端知道算法或行为的情况;
	2. 由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观;

和其他设计模式的区别;
	1. 与状态模式;
	在解决的问题上，状态模式是解决内在状态的改变，而策略模式是解决内部算法的改变。在解决的方法上，状态模式是自我控制状态的改变，而策略模式是由外部制定使用使用啥策略。
	2. 简单工厂模式;
	简单工厂模式是创建型模式，关注对象的创建;
	策略模式是行为型模式，关注行为的封装;
	简单工厂模式是根据不同的条件返回一个适合的类给你使用，然后调用者使用工厂类返回的类去完成相应的操作;
	而策略模式是必须首先创建一个想使用的类实例，然后实例被当作参数传递进去，既而通过该实例去调用不用的算法;
	在简单工厂模式中实现了通过条件选取一个类去实例化对象，策略模式则将选取相应对象的工作交给模式的使用者，它本身不去做选取工作;

*************************************************************************************************************************/